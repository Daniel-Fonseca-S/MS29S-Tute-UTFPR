<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - js_src\tute.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>js_src\tute.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.66</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1130</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">177.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.28</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { Tr } from &#039;./tr-es.js&#039;;

import { CardModel, Suit } from &#039;./cards.js&#039;;

import {
  AnimationController,
  MessageAnimator,
  MoveToBackAnimator,
  MoveToFrontAnimator,
  ReverseAnimator,
  TuteController,
  WaitAnimator
} from &#039;./animators.js&#039;;

import {
  PintaMovement,
  ThrowMovement,
  ThrowResponseMovement,
  TuteMovement,
  TwentyFortyMovement
} from &#039;./movements.js&#039;;

import { GameUI } from &#039;./gameui.js&#039;;

const Color =
{
  green: &#039;#00FF00&#039;,
  cyan: &#039;#00FFFF&#039;,
  yellow: &#039;#FFFF00&#039;,
  pink: &#039;#FF69B4&#039;
};

const TuteGame =
{
  NUM_CARDS_PER_PLAYER: 8,

  cardValueComparator: function (o1, o2) {
    const n = (TuteGame.pinta !== null &amp;&amp; o1.suit === TuteGame.pinta.suit ? 10 : o1.suit.index) -
      (TuteGame.pinta !== null &amp;&amp; o2.suit === TuteGame.pinta.suit ? 10 : o2.suit.index);

    if (n !== 0) { return n; }

    return o1.rank.relativeValue - o2.rank.relativeValue;
  },

  deck: [],
  player1Cards: [],
  player2Cards: [],
  player1Baza: [],
  player2Baza: [],
  pinta: null,

  skipCardCount: false,
  player1Games: 0,
  player2Games: 0,
  player1Turn: false,
  player1Mano: true,

  declarations: {},

  initialize: function () {
    for (const card of GameUI.cards) {
      card.moveTo(GameUI.BOARD_WIDTH / 2, GameUI.BOARD_HEIGHT / 2, 0);

      TuteGame.deck.push(card);
    }

    TuteGame.shuffleDeck();
  },

  shuffleDeck: function () {
    for (let i = TuteGame.deck.length - 1; i &gt; 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));

      [TuteGame.deck[i], TuteGame.deck[j]] = [TuteGame.deck[j], TuteGame.deck[i]];
    }

    for (const card of TuteGame.deck) { card.moveToFront(); }

    TuteGame.pinta = TuteGame.deck[TuteGame.deck.length - 1];

    TuteGame.pinta.moveToBack();

    GameUI.repaint();
  },

  hasCard: function (rank, suit, playerCards) {
    for (const c of playerCards) {
      if (c.rank === rank &amp;&amp; c.suit === suit) { return c; }
    }

    return null;
  },

  calculateIfFirstCardWins: function (card1, card2) {
    if ((card1.suit === this.pinta.suit) &amp;&amp; (card2.suit === this.pinta.suit)) { return card1.rank.relativeValue &gt; card2.rank.relativeValue; }

    if ((card1.suit === this.pinta.suit) !== (card2.suit === this.pinta.suit)) { return card1.suit === this.pinta.suit; }

    if (card1.suit === card2.suit) { return card1.rank.relativeValue &gt; card2.rank.relativeValue; }

    return true;
  },

  calculateAllowedCardsToAvoidRenuncio: function (firstCard, playerCards) {
    if (TuteGame.deck.length === 0) {
      const alternatives = [];

      for (const c of playerCards) {
        if (firstCard.suit === c.suit &amp;&amp;
          c.rank.relativeValue &gt; firstCard.rank.relativeValue) {
          alternatives.push(c);
        }
      }

      if (alternatives.length === 0) {
        for (const c of playerCards) {
          if (firstCard.suit === c.suit) {
            alternatives.push(c);
          }
        }
      }

      if (firstCard.suit !== TuteGame.pinta.suit) {
        for (const c of playerCards) {
          if (TuteGame.pinta.suit === c.suit) {
            alternatives.push(c);
          }
        }
      }

      if (alternatives.length &gt; 0) { return alternatives; }
    }

    return playerCards;
  },

  calculateIfRenuncio: function (firstCard, secondCard, playerCards) {
    const allowedCards =
      TuteGame.calculateAllowedCardsToAvoidRenuncio(firstCard, playerCards);

    return !allowedCards.includes(secondCard);
  },

  declareRenuncio: function (firstCard, secondCard) {
    let renuncio = false;

    if (this.player1Turn) {
      renuncio = this.calculateIfRenuncio(firstCard, secondCard, this.player2Cards);
    } else {
      renuncio = this.calculateIfRenuncio(firstCard, secondCard, this.player1Cards);
    }

    if (this.player1Turn) {
      if (renuncio) { this.player1Games += 2; } else { this.player2Games += 2; }
    } else if (renuncio) { this.player2Games += 2; } else { this.player1Games += 2; }

    TuteGameUI.updateGames();

    this.skipCardCount = true;
  },

  remove(arr, elem) {
    const index = arr.indexOf(elem);

    if (index &gt; -1) {
      arr.splice(index, 1);
      return true;
    }

    return false;
  },

  playCards: function (firstCard, secondCard) {
    const firstCardWins = TuteGame.calculateIfFirstCardWins(firstCard, secondCard);

    let player1Wins = false;

    if (TuteGame.player1Turn) {
      if (TuteGame.calculateIfRenuncio(firstCard, secondCard, TuteGame.player2Cards)) { throw new AssertionError(); }

      if (!TuteGame.remove(TuteGame.player1Cards, firstCard)) { throw new AssertionError(); }

      if (!TuteGame.remove(TuteGame.player2Cards, secondCard)) { throw new AssertionError(); }

      player1Wins = firstCardWins;
    } else {
      if (TuteGame.calculateIfRenuncio(firstCard, secondCard, TuteGame.player1Cards)) { throw new AssertionError(); }

      if (!TuteGame.remove(TuteGame.player2Cards, firstCard)) { throw new AssertionError(); }

      if (!TuteGame.remove(TuteGame.player1Cards, secondCard)) { throw new AssertionError(); }

      player1Wins = !firstCardWins;
    }

    if (player1Wins) {
      TuteGame.player1Baza.push(firstCard);
      TuteGame.player1Baza.push(secondCard);
    } else {
      TuteGame.player2Baza.push(firstCard);
      TuteGame.player2Baza.push(secondCard);
    }

    TuteGame.player1Turn = player1Wins;

    return player1Wins;
  },

  arePlayerCardsEmpty: function () {
    return this.player1Cards.length === 0 &amp;&amp; this.player2Cards.length === 0;
  },

  declare: function (suit) {
    if (this.canMakeDeclarations()) {
      if (this.player1Turn &amp;&amp;
        this.hasCard(CardModel.rankFromName(&#039;King&#039;), suit, this.player1Cards) !== null &amp;&amp;
        this.hasCard(CardModel.rankFromName(&#039;Knight&#039;), suit, this.player1Cards) !== null) {
        this.declarations[suit.name] = &#039;1&#039;;
        return;
      }

      if (!this.player1Turn &amp;&amp;
        this.hasCard(CardModel.rankFromName(&#039;King&#039;), suit, this.player2Cards) !== null &amp;&amp;
        this.hasCard(CardModel.rankFromName(&#039;Knight&#039;), suit, this.player2Cards) !== null) {
        this.declarations[suit.name] = &#039;2&#039;;
        return;
      }
    }

    throw new AssertionError();
  },

  getDeclaration: function (suit) {
    if (suit.name in this.declarations) { return this.declarations[suit.name]; }

    return null;
  },

  dealCardToPlayer: function (playerCards) {
    const c1 = this.deck.shift();

    playerCards.push(c1);

    playerCards = playerCards.sort(TuteGame.cardValueComparator);

    return c1;
  },

  dealCardToPlayer1: function () {
    return this.dealCardToPlayer(TuteGame.player1Cards);
  },

  dealCardToPlayer2: function () {
    return this.dealCardToPlayer(TuteGame.player2Cards);
  },

  getPlayer1CardChangeableByPinta: function () {
    return this.getCardChangeableByPinta(TuteGame.player1Cards);
  },

  getPlayer2CardChangeableByPinta: function () {
    return this.getCardChangeableByPinta(TuteGame.player2Cards);
  },

  getCardChangeableByPinta: function (playerCards) {
    if (this.pinta.rank.name !== &#039;V2&#039;) {
      for (const card of playerCards) {
        if (card.suit === this.pinta.suit) {
          if (card.rank.name === &#039;V7&#039; &amp;&amp;
            (this.pinta.rank.name === &#039;V8&#039; ||
              this.pinta.rank.name === &#039;V9&#039; ||
              this.pinta.rank.name === &#039;Knave&#039; ||
              this.pinta.rank.name === &#039;Knight&#039; ||
              this.pinta.rank.name === &#039;King&#039; ||
              this.pinta.rank.name === &#039;V3&#039; ||
              this.pinta.rank.name === &#039;Ace&#039;)) {
            return card;
          }

          if (card.rank.name === &#039;V2&#039; &amp;&amp;
            (this.pinta.rank.name === &#039;V4&#039; ||
              this.pinta.rank.name === &#039;V5&#039; ||
              this.pinta.rank.name === &#039;V6&#039; ||
              this.pinta.rank.name === &#039;V7&#039;)) {
            return card;
          }
        }
      }
    }

    return null;
  },

  changePintaPlayer: function (cardChangeableByPinta, playerCards) {
    if (!TuteGame.remove(playerCards, cardChangeableByPinta)) { throw new AssertionError(); }

    if (!playerCards.push(this.pinta)) { throw new AssertionError(); }

    playerCards = playerCards.sort(TuteGame.cardValueComparator);

    if (!TuteGame.remove(this.deck, this.pinta)) { throw new AssertionError(); }

    if (!this.deck.push(cardChangeableByPinta)) { throw new AssertionError(); }

    const previousPinta = this.pinta;

    this.pinta = cardChangeableByPinta;

    return previousPinta;
  },

  changePintaPlayer1: function () {
    return this.changePintaPlayer(this.getCardChangeableByPinta(this.player1Cards), this.player1Cards);
  },

  changePintaPlayer2: function () {
    return this.changePintaPlayer(this.getCardChangeableByPinta(this.player2Cards), this.player2Cards);
  },

  declareTute: function () {
    if (this.player1Turn &amp;&amp;
      (this.canDeclareTute(CardModel.rankFromName(&#039;Knight&#039;), TuteGame.player1Cards) ||
        this.canDeclareTute(CardModel.rankFromName(&#039;King&#039;), TuteGame.player1Cards))) {
      this.player1Games++;
      this.skipCardCount = true;
    } else if (!this.player1Turn &amp;&amp;
      (this.canDeclareTute(CardModel.rankFromName(&#039;Knight&#039;), TuteGame.player2Cards) ||
        this.canDeclareTute(CardModel.rankFromName(&#039;King&#039;), TuteGame.player2Cards))) {
      this.player2Games++;
      this.skipCardCount = true;
    } else {
      throw new AssertionError();
    }

    TuteGameUI.updateGames();
  },

  canMakeDeclarations: function () {
    return (this.player1Baza.length &gt; 0 || this.player2Baza.length &gt; 0) &amp;&amp; this.deck.length &gt; 0;
  },

  canDeclareTute: function (rank, playerCards) {
    if (!this.canMakeDeclarations()) { return false; }

    for (const suit of Suit) {
      if (this.hasCard(rank, suit, playerCards) === null) { return false; }
    }

    return true;
  },

  countPointsAndRestart: function (player1WinnedLastTrick) {
    if (!this.skipCardCount) {
      let player1Points = 0; let player2Points = 0;

      for (const card of this.player1Baza) { player1Points += card.rank.countValue; }

      for (const card of this.player2Baza) { player2Points += card.rank.countValue; }

      if (player1WinnedLastTrick) { player1Points += 10; } else { player2Points += 10; }

      for (const key in this.declarations) {
        const value = this.declarations[key];

        const points = key === this.pinta.suit.name ? 40 : 20;

        if (value === &#039;1&#039;) { player1Points += points; }

        if (value === &#039;2&#039;) { player2Points += points; }
      }

      if (player1Points &gt; player2Points) { this.player1Games++; } else if (player1Points &lt; player2Points) { this.player2Games++; }

      TuteGameUI.updateGames();
    }

    this.skipCardCount = false;

    this.deck = this.deck.concat(this.player1Cards);
    this.deck = this.deck.concat(this.player2Cards);
    this.deck = this.deck.concat(this.player1Baza);
    this.deck = this.deck.concat(this.player2Baza);

    this.declarations = {};

    this.player1Cards = [];
    this.player2Cards = [];
    this.player1Baza = [];
    this.player2Baza = [];

    this.player1Mano = !this.player1Mano;
    this.player1Turn = !this.player1Mano;

    this.shuffleDeck();
  }

};

const TuteAI =
{
  calculatePlayerCardBegin: function (myCards) {
    let candidateCardsToThrow = [];

    if (candidateCardsToThrow.length === 0) {
      if (TuteGame.deck.length === 0) {
        if (candidateCardsToThrow.length === 0) {
          let maximumValue = 0;

          for (const c of myCards) {
            if (c.suit !== TuteGame.pinta.suit) {
              if (c.rank.countValue === maximumValue) {
                candidateCardsToThrow.push(c);
              } else if (c.rank.countValue &gt; maximumValue) {
                maximumValue = c.rank.countValue;

                candidateCardsToThrow = [];

                candidateCardsToThrow.push(c);
              }
            }
          }
        }
      } else {
        if (candidateCardsToThrow.length === 0) {
          let minimumValue = CardModel.rankFromName(&#039;Ace&#039;).countValue;

          for (const c of myCards) {
            if (c.suit !== TuteGame.pinta.suit) {
              if (c.rank.countValue === minimumValue) {
                candidateCardsToThrow.push(c);
              } else if (c.rank.countValue &lt; minimumValue) {
                minimumValue = c.rank.countValue;

                candidateCardsToThrow = [];

                candidateCardsToThrow.push(c);
              }
            }
          }
        }
      }

      if (candidateCardsToThrow.length === 0) { candidateCardsToThrow.push(myCards[0]); }
    }

    return candidateCardsToThrow[parseInt(Math.random() * candidateCardsToThrow.length)];
  },

  calculatePlayerCardResponse: function (thrownCard) {
    const myCards = TuteGame.calculateAllowedCardsToAvoidRenuncio(thrownCard, TuteGame.player2Cards);

    const candidateCardsToThrow = [];

    if (thrownCard.rank.countValue === 0) {
      for (const c of myCards) {
        if (c.suit !== TuteGame.pinta.suit &amp;&amp;
          c.suit === thrownCard.suit &amp;&amp;
          (c.rank.name === &#039;Ace&#039; || c.rank.name === &#039;V3&#039;)) {
          candidateCardsToThrow.push(c);
        }
      }

      if (candidateCardsToThrow.length === 0) { return this.calculatePlayerCardBegin(myCards); }
    } else {
      if (candidateCardsToThrow.length === 0) {
        for (const c of myCards) {
          if (c.suit !== TuteGame.pinta.suit &amp;&amp;
            c.suit === thrownCard.suit &amp;&amp;
            c.rank.countValue &gt; thrownCard.rank.countValue &amp;&amp;
            (c.rank.name === &#039;Ace&#039; || c.rank.name === &#039;V3&#039;)) {
            candidateCardsToThrow.push(c);
          }
        }
      }

      if (candidateCardsToThrow.length === 0) {
        for (const c of myCards) {
          if (c.suit === thrownCard.suit &amp;&amp;
            c.rank.countValue &gt; thrownCard.rank.countValue) {
            candidateCardsToThrow.push(c);
          }
        }
      }

      if (candidateCardsToThrow.length === 0) {
        if (thrownCard.suit !== TuteGame.pinta.suit) {
          for (const c of myCards) {
            if (c.suit === TuteGame.pinta.suit &amp;&amp;
              c.rank.countValue === 0) {
              candidateCardsToThrow.push(c);
            }
          }
        }
      }
    }

    if (candidateCardsToThrow.length === 0) { candidateCardsToThrow.push(myCards[0]); }

    return candidateCardsToThrow[parseInt(Math.random() * candidateCardsToThrow.length)];
  }
};

const HumanPlayer =
{
  hoverCard: null,

  otherCurrentCards: [],

  onMouseOver: function (card, over) {
    if (over) {
      if (HumanPlayer.hoverCard === card) { return; }

      HumanPlayer.clearSelection();

      HumanPlayer.hoverCard = card;
    } else if (HumanPlayer.hoverCard !== null) {
      HumanPlayer.clearSelection();

      HumanPlayer.hoverCard = null;
    }

    HumanPlayer._onMouseOver();
  },

  lastTouchedMovement: null,

  is_touch_device: function () {
    const prefixes = &#039; -webkit- -moz- -o- -ms- &#039;.split(&#039; &#039;);
    const mq = function (query) {
      return window.matchMedia(query).matches;
    };

    if ((&#039;ontouchstart&#039; in window) || (window.DocumentTouch &amp;&amp; document instanceof DocumentTouch)) {
      return true;
    }

    // include the &#039;heartz&#039; as a way to have a non matching MQ to help terminate the join
    // https://git.io/vznFH
    const query = [&#039;(&#039;, prefixes.join(&#039;touch-enabled),(&#039;), &#039;heartz&#039;, &#039;)&#039;].join(&#039;&#039;);
    return mq(query);
  },

  _onMouseOver: function () {
    if (!HumanPlayer.is_touch_device()) {
      const movement = HumanPlayer.getPlayerMovement();

      if (movement !== null) { $(&#039;#player1Message&#039;).html(movement.toString()); }
    }
  },

  getPlayerMovement: function () {
    $(&#039;#player1Message&#039;).html(&#039;&#039;);

    const touchedMovement = HumanPlayer._getPlayerMovement();

    if (HumanPlayer.is_touch_device()) {
      if (touchedMovement !== null &amp;&amp;
        HumanPlayer.lastTouchedMovement !== null &amp;&amp;
        touchedMovement.toString() === HumanPlayer.lastTouchedMovement.toString()) {
        return touchedMovement;
      } else {
        $(&#039;#player1Message&#039;).html(touchedMovement.toString());

        HumanPlayer.lastTouchedMovement = touchedMovement;
      }

      return null;
    } else {
      return touchedMovement;
    }
  },

  _getPlayerMovement: function () {
    if (HumanPlayer.hoverCard !== null) {
      if (TuteGame.player1Turn) {
        if (TuteGame.canMakeDeclarations()) {
          if (HumanPlayer.hoverCard === TuteGame.pinta &amp;&amp; TuteGame.getPlayer1CardChangeableByPinta() !== null) {
            HumanPlayer.hoverCard.setHighlightColor(Color.green);

            return new PintaMovement();
          }
        }

        if (TuteGame.player1Cards.includes(HumanPlayer.hoverCard)) {
          if (TuteGame.canMakeDeclarations()) {
            if (HumanPlayer.hoverCard.rank.name === &#039;King&#039; || HumanPlayer.hoverCard.rank.name === &#039;Knight&#039;) {
              if (TuteGame.canDeclareTute(HumanPlayer.hoverCard.rank, TuteGame.player1Cards)) {
                for (const c of TuteGame.player1Cards) {
                  if (c.rank === HumanPlayer.hoverCard.rank) {
                    HumanPlayer.otherCurrentCards.push(c);

                    c.setHighlightColor(Color.cyan);
                  }
                }

                return new TuteMovement(HumanPlayer.hoverCard.rank);
              }
            }

            if (HumanPlayer.hoverCard.rank.name === &#039;King&#039; &amp;&amp;
              TuteGame.getDeclaration(TuteGame.pinta.suit) === null &amp;&amp;
              TuteGame.getDeclaration(HumanPlayer.hoverCard.suit) === null) {
              const knight = TuteGame.hasCard(CardModel.rankFromName(&#039;Knight&#039;), HumanPlayer.hoverCard.suit, TuteGame.player1Cards);

              if (knight !== null) {
                HumanPlayer.otherCurrentCards.push(knight);

                HumanPlayer.hoverCard.setHighlightColor(Color.cyan);

                knight.setHighlightColor(Color.cyan);

                return new TwentyFortyMovement(TuteGame.pinta.suit, HumanPlayer.hoverCard.suit);
              }
            }
          }

          HumanPlayer.hoverCard.setHighlightColor(Color.yellow);

          return new ThrowMovement(HumanPlayer.hoverCard);
        }
      } else if (TuteGame.player1Cards.includes(HumanPlayer.hoverCard)) {
        if (TuteGame.calculateIfRenuncio(TuteGameUI.player2playedCard, HumanPlayer.hoverCard, TuteGame.player1Cards)) { HumanPlayer.hoverCard.setHighlightColor(Color.pink); } else { HumanPlayer.hoverCard.setHighlightColor(Color.yellow); }

        return new ThrowResponseMovement(HumanPlayer.hoverCard);
      }
    }

    return null;
  },

  clearSelection: function () {
    if (HumanPlayer.hoverCard !== null) { HumanPlayer.hoverCard.setHighlightColor(null); }

    HumanPlayer.hoverCard = null;

    for (const c of HumanPlayer.otherCurrentCards) { c.setHighlightColor(null); }

    HumanPlayer.otherCurrentCards = [];
  }
};

const TuteGameUI =
{
  initialize: function () {
    TuteGameUI.updateGames();

    for (const card of GameUI.cards) { AnimationController.add(new ReverseAnimator(card, false)); }

    AnimationController.add(TuteController.getDeckCardMove(GameUI.cards));

    for (let i = 0; i &lt; TuteGame.NUM_CARDS_PER_PLAYER; i++) { TuteGameUI.dealNewCards(); }

    AnimationController.add(new ReverseAnimator(TuteGame.pinta, true));

    AnimationController.add(TuteController.relocatePlayer1Cards(TuteGame.player1Cards));

    AnimationController.add(TuteController.relocatePlayer2Cards(TuteGame.player2Cards));

    AnimationController.add(TuteController.getPintaMovement(TuteGame.pinta));

    AnimationController.add(new WaitAnimator(50));

    AnimationController.addF(function () {
      TuteGameUI.startTurn();

      return true;
    });
  },

  dealNewCards: function () {
    if (TuteGame.deck.length === 0) { return; }

    if (TuteGame.player1Turn) {
      const c1 = TuteGame.dealCardToPlayer1();

      AnimationController.add(new MoveToFrontAnimator(c1));

      AnimationController.add(TuteController.getPlayer1CardThrow(c1));

      AnimationController.add(new ReverseAnimator(c1, true));
    }

    const c2 = TuteGame.dealCardToPlayer2();

    AnimationController.add(new MoveToFrontAnimator(c2));

    AnimationController.add(TuteController.getPlayer2PlayerCardThrow(c2));

    AnimationController.add(new ReverseAnimator(c2, false));

    if (!TuteGame.player1Turn) {
      const c1 = TuteGame.dealCardToPlayer1();

      AnimationController.add(new MoveToFrontAnimator(c1));

      AnimationController.add(TuteController.getPlayer1CardThrow(c1));

      AnimationController.add(new ReverseAnimator(c1, true));
    }
  },

  startTurn: function () {
    if (TuteGame.canMakeDeclarations()) {
      const cardChangeableByPinta = TuteGame.getPlayer2CardChangeableByPinta();

      if (cardChangeableByPinta !== null) {
        AnimationController.add(new ReverseAnimator(cardChangeableByPinta, true));

        AnimationController.add(new MoveToFrontAnimator(cardChangeableByPinta));

        AnimationController.add(TuteController.getPlayer2PintaCardThrow(cardChangeableByPinta));

        AnimationController.add(new MoveToBackAnimator(cardChangeableByPinta));

        AnimationController.add(new MessageAnimator(Tr.getChangePintaString(), 100));

        const previousPinta = TuteGame.changePintaPlayer2();

        AnimationController.add(TuteController.relocatePlayer2Cards(TuteGame.player2Cards));

        AnimationController.add(TuteController.getPintaMovement(TuteGame.pinta));

        AnimationController.add(new ReverseAnimator(previousPinta, false));

        AnimationController.addF(function () {
          TuteGameUI.startTurn();

          return true;
        });

        return;
      }
    }

    if (!TuteGame.player1Turn &amp;&amp; TuteGame.player1Cards.length &gt; 0) {
      if (TuteGame.canMakeDeclarations()) {
        for (const rank of [CardModel.rankFromName(&#039;King&#039;), CardModel.rankFromName(&#039;Knight&#039;)]) {
          if (TuteGame.canDeclareTute(rank, TuteGame.player2Cards)) {
            for (const c of TuteGame.player2Cards) {
              if (c.rank === rank) { AnimationController.add(new ReverseAnimator(c, true)); }
            }

            AnimationController.addF(function () {
              TuteGameUI.tute(rank);
              return true;
            });

            return;
          }
        }

        for (const declarationSuit of Suit) {
          if (TuteGame.getDeclaration(declarationSuit) !== null ||
            TuteGame.getDeclaration(TuteGame.pinta.suit) !== null) { continue; }

          const knight = TuteGame.hasCard(CardModel.rankFromName(&#039;Knight&#039;), declarationSuit, TuteGame.player2Cards);
          const king = TuteGame.hasCard(CardModel.rankFromName(&#039;King&#039;), declarationSuit, TuteGame.player2Cards);

          if (knight !== null &amp;&amp; king !== null) {
            TuteGame.declare(declarationSuit);

            AnimationController.add(new WaitAnimator(20));

            AnimationController.add(new ReverseAnimator(knight, true));
            AnimationController.add(new ReverseAnimator(king, true));

            AnimationController.add(new MessageAnimator(
              Tr.getTwentyFortyDeclarationString(TuteGame.pinta.suit, declarationSuit), 100));

            AnimationController.addF(function () {
              TuteGameUI.fireWaitForUserClick(true);

              return true;
            });

            AnimationController.add(new ReverseAnimator(knight, false));
            AnimationController.add(new ReverseAnimator(king, false));

            AnimationController.addF(function () {
              TuteGameUI.startTurn();

              return true;
            });

            return;
          }
        }
      }

      AnimationController.add(new WaitAnimator(20));

      TuteGameUI.player2playedCard = TuteAI.calculatePlayerCardBegin(TuteGame.player2Cards);

      AnimationController.add(new ReverseAnimator(TuteGameUI.player2playedCard, true));

      AnimationController.add(new MoveToFrontAnimator(TuteGameUI.player2playedCard));

      AnimationController.add(TuteController.getCenterCardThrow(TuteGameUI.player2playedCard));
    }

    AnimationController.addF(function () {
      TuteGameUI.fireWaitForUserClick(true);

      return true;
    });
  },

  fireWaitForUserClick: function (enable) {
    for (const card of GameUI.cards) { card.highlightingEnabled = enable; }

    if (enable) {
      GameUI.onCardClick = function (card) {
        const movement = HumanPlayer.getPlayerMovement();

        if (movement !== null) { TuteGameUI.onHumanMovement(movement); }

        GameUI.repaint();
      };

      GameUI.onCardMouseEnter = function (card) {
        HumanPlayer.onMouseOver(card, true);
      };

      GameUI.onCardMouseLeave = function (card) {
        HumanPlayer.onMouseOver(card, false);
      };
    } else {
      GameUI.onCardClick = null;
      GameUI.onCardMouseEnter = null;
      GameUI.onCardMouseLeave = null;
    }
  },

  onHumanMovement: function (movement) {
    if (movement !== null) {
      this.fireWaitForUserClick(false);

      if (movement instanceof PintaMovement) {
        const cardChangeableByPinta = TuteGame.getPlayer1CardChangeableByPinta();

        if (cardChangeableByPinta === null) { throw new AssertionError(); }

        AnimationController.add(new MoveToFrontAnimator(cardChangeableByPinta));

        AnimationController.add(TuteController.getPlayer1PintaCardThrow(cardChangeableByPinta));

        AnimationController.add(new MoveToBackAnimator(cardChangeableByPinta));

        AnimationController.add(new MessageAnimator(Tr.getChangePintaString(), 100));

        TuteGame.changePintaPlayer1();

        AnimationController.add(TuteController.relocatePlayer1Cards(TuteGame.player1Cards));

        AnimationController.add(TuteController.getPintaMovement(TuteGame.pinta));

        AnimationController.addF(function () {
          TuteGameUI.fireWaitForUserClick(true);

          return true;
        });
      } else if (movement instanceof TuteMovement) {
        TuteGameUI.tute(movement.rank);

        return;
      } else if (movement instanceof TwentyFortyMovement) {
        TuteGame.declare(movement.suit);

        AnimationController.add(new MessageAnimator(
          Tr.getTwentyFortyDeclarationString(
            TuteGame.pinta.suit, movement.suit), 100));

        AnimationController.addF(function () {
          TuteGameUI.fireWaitForUserClick(true);

          return true;
        });
      } else if (movement instanceof ThrowMovement) {
        const currentCard = movement.currentCard;

        AnimationController.add(new MoveToFrontAnimator(currentCard));

        AnimationController.add(TuteController.getCenterCardThrow(currentCard));

        AnimationController.add(new WaitAnimator(20));

        const player2Card = TuteAI.calculatePlayerCardResponse(currentCard);

        AnimationController.add(new MoveToFrontAnimator(player2Card));

        AnimationController.add(TuteController.getCenterCardThrow(player2Card));

        AnimationController.add(new ReverseAnimator(player2Card, true));

        const player1Wins = TuteGame.playCards(currentCard, player2Card);

        TuteGameUI.playTurn(currentCard, player2Card, player1Wins);
      } else if (movement instanceof ThrowResponseMovement) {
        const currentCard = movement.currentCard;

        AnimationController.add(new MoveToFrontAnimator(currentCard));

        AnimationController.add(TuteController.getCenterCardThrow(currentCard));

        if (TuteGame.calculateIfRenuncio(TuteGameUI.player2playedCard, currentCard, TuteGame.player1Cards)) {
          TuteGameUI.renuncio(currentCard);

          return;
        } else {
          const player1Wins = TuteGame.playCards(TuteGameUI.player2playedCard, currentCard);

          TuteGameUI.playTurn(currentCard, TuteGameUI.player2playedCard, player1Wins);

          TuteGameUI.player2playedCard = null;
        }
      }
    }

    HumanPlayer.clearSelection();
  },

  playTurn: function (card1, card2, player1Wins) {
    AnimationController.add(new WaitAnimator(20));

    if (player1Wins) { AnimationController.add(TuteController.getPlayer1WinDeckMovement(card1, card2)); } else { AnimationController.add(TuteController.getPlayer2WinDeckMovement(card1, card2)); }

    AnimationController.addF(function () {
      TuteGameUI.newTurn(player1Wins);

      return true;
    });
  },

  newTurn: function (player1WonLastTrick) {
    if (TuteGame.arePlayerCardsEmpty()) {
      TuteGameUI.completeGame(player1WonLastTrick);
    } else {
      TuteGameUI.dealNewCards();

      AnimationController.add(TuteController.relocatePlayer1Cards(TuteGame.player1Cards));

      AnimationController.add(TuteController.relocatePlayer2Cards(TuteGame.player2Cards));

      AnimationController.addF(function () {
        GameUI.repaint();

        TuteGameUI.startTurn();

        return true;
      });
    }
  },

  completeGame(player1WonLastTrick) {
    HumanPlayer.clearSelection();

    const player1Wins = TuteGame.player1Baza.reverse();
    const player2Wins = TuteGame.player2Baza.reverse();

    AnimationController.add(TuteController.getCenterWinCardThrow(player1Wins));

    this.player1Points = 0;
    this.player2Points = 0;

    for (const card of player1Wins) {
      AnimationController.add(new MoveToFrontAnimator(card));
      AnimationController.add(TuteController.getCenterCardThrow(card));
      AnimationController.add(new ReverseAnimator(card, true));

      if (card.rank.countValue &gt; 0) {
        AnimationController.addF(function () {
          TuteGameUI.player1Points += card.rank.countValue;
          TuteGameUI.updateGames();
          return true;
        });

        AnimationController.add(new MessageAnimator(Tr.getPlusPointsString(card.rank.countValue), 30));
      }
    }

    if (player1WonLastTrick) {
      AnimationController.add(new WaitAnimator(15));

      AnimationController.addF(function () {
        TuteGameUI.player1Points += 10;
        TuteGameUI.updateGames();
        return true;
      });

      AnimationController.add(new MessageAnimator(Tr.getPlus10DeMonteString(), 30));
    }

    for (const suit of Suit) {
      const declaration = TuteGame.getDeclaration(suit);

      if (declaration === &#039;1&#039;) {
        AnimationController.add(new WaitAnimator(15));

        const points = suit === TuteGame.pinta.suit ? 40 : 20;

        AnimationController.addF(function () {
          TuteGameUI.player1Points += points;
          TuteGameUI.updateGames();
          return true;
        });

        AnimationController.add(new MessageAnimator(Tr.getPlusTwentyFortyPointsString(points, suit), 30));
      }
    }

    AnimationController.add(new WaitAnimator(50));

    AnimationController.add(TuteController.getCenterWinCardThrow(player2Wins));

    for (const card of player2Wins) {
      AnimationController.add(new MoveToFrontAnimator(card));
      AnimationController.add(TuteController.getCenterCardThrow(card));
      AnimationController.add(new ReverseAnimator(card, true));

      if (card.rank.countValue &gt; 0) {
        AnimationController.addF(function () {
          TuteGameUI.player2Points += card.rank.countValue;
          TuteGameUI.updateGames();
          return true;
        });

        AnimationController.add(new MessageAnimator(Tr.getPlusPointsString(card.rank.countValue), 30));
      }
    }

    if (!player1WonLastTrick) {
      AnimationController.add(new WaitAnimator(15));

      AnimationController.addF(function () {
        TuteGameUI.player2Points += 10;
        TuteGameUI.updateGames();
        return true;
      });

      AnimationController.add(new MessageAnimator(Tr.getPlus10DeMonteString(), 30));
    }

    for (const suit of Suit) {
      const declaration = TuteGame.getDeclaration(suit);

      if (declaration === &#039;2&#039;) {
        AnimationController.add(new WaitAnimator(15));

        const points = suit === TuteGame.pinta.suit ? 40 : 20;

        AnimationController.addF(function () {
          TuteGameUI.player2Points += points;
          TuteGameUI.updateGames();
          return true;
        });

        AnimationController.add(new MessageAnimator(Tr.getPlusTwentyFortyPointsString(points, suit), 30));
      }
    }

    AnimationController.addF(function () {
      TuteGame.countPointsAndRestart(player1WonLastTrick);

      return true;
    });

    AnimationController.add(new WaitAnimator(100));

    AnimationController.add(TuteController.getCenterCardMove(GameUI.cards));

    AnimationController.addF(function () {
      TuteGameUI.player1Points = TuteGameUI.player2Points = -1;

      TuteGameUI.initialize();

      return true;
    });
  },

  renuncio: function (currentCard) {
    TuteGame.declareRenuncio(this.player2playedCard, currentCard);

    this.abortGame(Tr.getDeclareRenuncioString());
  },

  tute: function (rank) {
    TuteGame.declareTute();

    this.abortGame(Tr.getTuteDeclarationString(rank));
  },

  abortGame: function (message) {
    AnimationController.add(new MessageAnimator(message, 100));

    AnimationController.add(TuteController.getCenterCardMove(GameUI.cards));

    HumanPlayer.clearSelection();

    AnimationController.addF(function () {
      TuteGame.countPointsAndRestart(TuteGame.player1Turn);
      TuteGameUI.initialize();
      return true;
    });
  },

  updateGames: () =&gt; {
    if (TuteGameUI.player1Points &gt; 0) { $(&#039;#player1Points&#039;).html(Tr.getPlayerPointsString(TuteGameUI.player1Points)); } else { $(&#039;#player1Points&#039;).html(&#039;&#039;); }

    if (TuteGameUI.player2Points &gt; 0) { $(&#039;#player2Points&#039;).html(Tr.getPlayerPointsString(TuteGameUI.player2Points)); } else { $(&#039;#player2Points&#039;).html(&#039;&#039;); }

    $(&#039;#player2Message&#039;).html(Tr.getPlayerGamesString(TuteGame.player1Games, TuteGame.player2Games));
  }
};

$(() =&gt; {
  $(&#039;title&#039;).html(Tr.getWindowTitle());

  GameUI.initialize();

  $(window).resize(GameUI.onResize);

  GameUI.repaint();

  AnimationController.initialize();

  TuteGame.initialize();

  TuteGameUI.initialize();
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
