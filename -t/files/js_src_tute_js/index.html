<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - js_src\tute.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>js_src\tute.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.65</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1403</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">179.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.36</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">import { Tr } from &quot;./tr-es.js&quot;;

import { Suit, Rank, CardModel, Card } from &quot;./cards.js&quot;;

import { AnimationController, 
		MoveCardAnimator, 
		ThrowCardAnimator, 
		MoveToBackAnimator, 
		MoveToFrontAnimator, 
		ReverseAnimator, 
		MessageAnimator,
		WaitAnimator,
		MultiAnimator,
		TuteController } from &quot;./animators.js&quot;;

import { PintaMovement,
		ThrowMovement,
		ThrowResponseMovement,
		TuteMovement,
		TwentyFortyMovement	} from &quot;./movements.js&quot;;

import { GameUI } from &quot;./gameui.js&quot;;

const Color = 
{
	green:  &quot;#00FF00&quot;,
	cyan:   &quot;#00FFFF&quot;,
	yellow: &quot;#FFFF00&quot;,
	pink:   &quot;#FF69B4&quot;
}

const TuteGame =
{
    NUM_CARDS_PER_PLAYER: 8,

    cardValueComparator: function(o1, o2)
    {
		let n = (TuteGame.pinta != null &amp;&amp; o1.suit == TuteGame.pinta.suit ? 10 : o1.suit.index) - 
				(TuteGame.pinta != null &amp;&amp; o2.suit == TuteGame.pinta.suit ? 10 : o2.suit.index);
		
		if (n != 0)
			return n;
		
		return o1.rank.relativeValue - o2.rank.relativeValue;
    },
	
    deck: [],
    player1Cards: [],
    player2Cards: [],
    player1Baza: [],
    player2Baza: [],
    pinta: null,

    skipCardCount: false,
    player1Games: 0,
    player2Games: 0,
    player1Turn: false,
    player1Mano: true,

    declarations: {},

    initialize: function()
    {
        for (let card of GameUI.cards)
        {
            card.moveTo(GameUI.BOARD_WIDTH / 2, GameUI.BOARD_HEIGHT / 2, 0)

            TuteGame.deck.push(card);
        }

        TuteGame.shuffleDeck();

    },

    shuffleDeck: function()
    {
        for (let i = TuteGame.deck.length - 1; i &gt; 0; i--)
        {
            const j = Math.floor(Math.random() * (i + 1));

            [TuteGame.deck[i], TuteGame.deck[j]] = [TuteGame.deck[j], TuteGame.deck[i]];
        }
		
        for (let card of TuteGame.deck)
            card.moveToFront();

        TuteGame.pinta = TuteGame.deck[TuteGame.deck.length - 1];

        TuteGame.pinta.moveToBack();
		
        GameUI.repaint();
	},

    hasCard: function(rank, suit, playerCards)
    {
        for (let c of playerCards)
        {
            if (c.rank == rank &amp;&amp; c.suit == suit)
                return c;
        }

        return null;
    },

    calculateIfFirstCardWins: function(card1, card2)
    {
        if ((card1.suit == this.pinta.suit) &amp;&amp; (card2.suit == this.pinta.suit))
            return card1.rank.relativeValue &gt; card2.rank.relativeValue;

        if ((card1.suit == this.pinta.suit) != (card2.suit == this.pinta.suit))
            return card1.suit == this.pinta.suit;

        if (card1.suit == card2.suit)
            return card1.rank.relativeValue &gt; card2.rank.relativeValue;

        return true;
    },

    calculateAllowedCardsToAvoidRenuncio: function(firstCard, playerCards)
    {
        if (TuteGame.deck.length == 0)
        {
            let alternatives = [];
            
            for (let c of playerCards)
            {
                if (firstCard.suit == c.suit 
                        &amp;&amp; c.rank.relativeValue &gt; firstCard.rank.relativeValue)
                {
                    alternatives.push(c);
                }
            }
    
            if (alternatives.length == 0)
			{
				for (let c of playerCards)
				{
					if (firstCard.suit == c.suit)
					{
						alternatives.push(c);
					}
				}
			}
            
			if (firstCard.suit != TuteGame.pinta.suit)
			{
				for (let c of playerCards)
				{
					if (TuteGame.pinta.suit == c.suit)
					{
						alternatives.push(c);
					}
				}
			}
            
            if (alternatives.length &gt; 0)
                return alternatives;
        }
        
        return playerCards;
    },
    
    calculateIfRenuncio: function(firstCard, secondCard, playerCards)
    {
        let allowedCards = 
                TuteGame.calculateAllowedCardsToAvoidRenuncio(firstCard, playerCards);
        
        return !allowedCards.includes(secondCard);
    },
	
    declareRenuncio: function(firstCard, secondCard)
    {
        let renuncio = false;
        
        if (this.player1Turn)
        {
            renuncio = this.calculateIfRenuncio(firstCard, secondCard, this.player2Cards);
        }
        else
        {
            renuncio = this.calculateIfRenuncio(firstCard, secondCard, this.player1Cards);
        }
        
        if (this.player1Turn)
        {
            if (renuncio)
                this.player1Games += 2;
            else
                this.player2Games += 2;
        }
        else // if (!player1Turn)
        {
            if (renuncio)
                this.player2Games += 2;
            else
                this.player1Games += 2;
        }
		
		TuteGameUI.updateGames();

        this.skipCardCount = true;
    },
    
	remove(arr, elem)
	{
		let index = arr. indexOf(elem);
	
		if (index &gt; -1)
		{
			arr.splice(index, 1)
			return true;
		}
		
		return false;
	},
    
    playCards: function(firstCard, secondCard)
    {
        let firstCardWins = TuteGame.calculateIfFirstCardWins(firstCard, secondCard);
        
        let player1Wins = false;
        
        if (TuteGame.player1Turn)
        {
            if (TuteGame.calculateIfRenuncio(firstCard, secondCard, TuteGame.player2Cards))
                throw new AssertionError();
            
            if (!TuteGame.remove(TuteGame.player1Cards, firstCard))
                throw new AssertionError();
            
            if (!TuteGame.remove(TuteGame.player2Cards, secondCard))
                throw new AssertionError();
            
            player1Wins = firstCardWins;
        }
        else
        {
            if (TuteGame.calculateIfRenuncio(firstCard, secondCard, TuteGame.player1Cards))
                throw new AssertionError();

            if (!TuteGame.remove(TuteGame.player2Cards, firstCard))
                throw new AssertionError();
            
            if (!TuteGame.remove(TuteGame.player1Cards, secondCard))
                throw new AssertionError();
            
            player1Wins = !firstCardWins;
        }
        
        if (player1Wins)
        {
            TuteGame.player1Baza.push(firstCard);
            TuteGame.player1Baza.push(secondCard);
        }
        else
        {
            TuteGame.player2Baza.push(firstCard);
            TuteGame.player2Baza.push(secondCard);
        }
        
        TuteGame.player1Turn = player1Wins;

        return player1Wins;
    },

    arePlayerCardsEmpty: function()
    {
        return this.player1Cards.length == 0 &amp;&amp; this.player2Cards.length == 0;
    },

    declare: function(suit)
    {
        if (this.canMakeDeclarations())
        {
			if (this.player1Turn &amp;&amp; 
				this.hasCard(CardModel.rankFromName(&quot;King&quot;),   suit, this.player1Cards) != null &amp;&amp; 
				this.hasCard(CardModel.rankFromName(&quot;Knight&quot;), suit, this.player1Cards) != null)
			{
				this.declarations[suit.name] = &quot;1&quot;;
				return;
			}

			if (!this.player1Turn &amp;&amp; 
				this.hasCard(CardModel.rankFromName(&quot;King&quot;),   suit, this.player2Cards) != null &amp;&amp; 
				this.hasCard(CardModel.rankFromName(&quot;Knight&quot;), suit, this.player2Cards) != null)
			{
				this.declarations[suit.name] = &quot;2&quot;;
				return;
			}
		}
        
        throw new AssertionError();
    },
    
    getDeclaration: function(suit)
    {
        if (suit.name in this.declarations)
			return this.declarations[suit.name];
		
		return null;
    },

    dealCardToPlayer: function(playerCards)
    {
        const c1 = this.deck.shift();

        playerCards.push(c1);
		
		playerCards = playerCards.sort(TuteGame.cardValueComparator);

        return c1;
    },

    dealCardToPlayer1: function()
    {
        return this.dealCardToPlayer(TuteGame.player1Cards);
    },

    dealCardToPlayer2: function()
    {
        return this.dealCardToPlayer(TuteGame.player2Cards);
    },

    getPlayer1CardChangeableByPinta: function()
    {
        return this.getCardChangeableByPinta(TuteGame.player1Cards);
    },

    getPlayer2CardChangeableByPinta: function()
    {
        return this.getCardChangeableByPinta(TuteGame.player2Cards);
    },

    getCardChangeableByPinta: function(playerCards)
    {
        if (this.pinta.rank.name != &quot;V2&quot;)
        {
            for (let card of playerCards)
            {
                if (card.suit == this.pinta.suit)
                {
                    if (card.rank.name == &quot;V7&quot; &amp;&amp;
                       (this.pinta.rank.name == &quot;V8&quot; ||
                        this.pinta.rank.name == &quot;V9&quot; ||
                        this.pinta.rank.name == &quot;Knave&quot; ||
                        this.pinta.rank.name == &quot;Knight&quot; ||
                        this.pinta.rank.name == &quot;King&quot; ||
                        this.pinta.rank.name == &quot;V3&quot; ||
                        this.pinta.rank.name == &quot;Ace&quot;))
                    {
                        return card;
                    }

                    if (card.rank.name == &quot;V2&quot; &amp;&amp;
                        (this.pinta.rank.name == &quot;V4&quot; ||
                         this.pinta.rank.name == &quot;V5&quot; ||
                         this.pinta.rank.name == &quot;V6&quot; ||
                         this.pinta.rank.name == &quot;V7&quot;))
                    {
                        return card;
                    }
                }
            }
        }

        return null;
    },

	changePintaPlayer: function(cardChangeableByPinta, playerCards)
    {
        if (!TuteGame.remove(playerCards, cardChangeableByPinta))
            throw new AssertionError();
        
        if (!playerCards.push(this.pinta))
            throw new AssertionError();
		
		playerCards = playerCards.sort(TuteGame.cardValueComparator);
        
        if (!TuteGame.remove(this.deck, this.pinta))
            throw new AssertionError();
        
        if (!this.deck.push(cardChangeableByPinta))
            throw new AssertionError();
        
        let previousPinta = this.pinta;
        
        this.pinta = cardChangeableByPinta;
        
        return previousPinta;
    },
    
    changePintaPlayer1: function()
    {
        return this.changePintaPlayer(this.getCardChangeableByPinta(this.player1Cards), this.player1Cards);
    },

    changePintaPlayer2: function()
    {
        return this.changePintaPlayer(this.getCardChangeableByPinta(this.player2Cards), this.player2Cards);
    },
    
    declareTute: function()
    {
        if (this.player1Turn &amp;&amp;
                (this.canDeclareTute(CardModel.rankFromName(&quot;Knight&quot;), TuteGame.player1Cards) ||
                 this.canDeclareTute(CardModel.rankFromName(&quot;King&quot;),   TuteGame.player1Cards)))
        {
            this.player1Games ++;
            this.skipCardCount = true;
        }
        else if (!this.player1Turn &amp;&amp;
                (this.canDeclareTute(CardModel.rankFromName(&quot;Knight&quot;), TuteGame.player2Cards) ||
                 this.canDeclareTute(CardModel.rankFromName(&quot;King&quot;),   TuteGame.player2Cards)))
        {
            this.player2Games ++;
            this.skipCardCount = true;
        }
        else
        {
            throw new AssertionError();
        }
		
		TuteGameUI.updateGames();
    },

	canMakeDeclarations: function()
	{
		return (this.player1Baza.length &gt; 0 || this.player2Baza.length &gt; 0) &amp;&amp; this.deck.length &gt; 0;
	},
	
    canDeclareTute: function(rank, playerCards)
    {
        if (!this.canMakeDeclarations())
            return false;
            
		for (let suit of Suit)
		{
			if (this.hasCard(rank, suit, playerCards) == null)
				return false;
		}
		
        return true;
    },
	
    countPointsAndRestart: function(player1WinnedLastTrick)
    {
        if (!this.skipCardCount)
        {
            let player1Points = 0, player2Points = 0;
            
            for (let card of this.player1Baza)
                player1Points += card.rank.countValue;
                
            for (let card of this.player2Baza)
                player2Points += card.rank.countValue;
            
            if (player1WinnedLastTrick)
                player1Points += 10;
            else
                player2Points += 10;
            
            for (let key in this.declarations)
            {
				let value = this.declarations[key];
				
                let points = key == this.pinta.suit.name ? 40 : 20;
                
                if (value == &quot;1&quot;)
                    player1Points += points;
    
                if (value == &quot;2&quot;)
                    player2Points += points;
            }
            
            if (player1Points &gt; player2Points)
                this.player1Games ++;
    
            else if (player1Points &lt; player2Points)
                this.player2Games ++;
			
			TuteGameUI.updateGames();
        }
            
        this.skipCardCount = false;
        
        this.deck = this.deck.concat(this.player1Cards);
        this.deck = this.deck.concat(this.player2Cards);
        this.deck = this.deck.concat(this.player1Baza);
        this.deck = this.deck.concat(this.player2Baza);
        
		this.declarations = {};
		
        this.player1Cards = [];
        this.player2Cards = [];
        this.player1Baza  = [];
        this.player2Baza  = [];
        
        this.player1Mano = !this.player1Mano;
        this.player1Turn = !this.player1Mano;
        
        this.shuffleDeck();
    }

}

const TuteAI =
{
    calculatePlayerCardBegin: function(myCards)
    {
        let candidateCardsToThrow = [];

        if (candidateCardsToThrow.length == 0)
        {
            if (TuteGame.deck.length == 0)
            {
                if (candidateCardsToThrow.length == 0)
                {
                    let maximumValue = 0;

                    for (let c of myCards)
                    {
                        if (c.suit != TuteGame.pinta.suit)
                        {
                            if (c.rank.countValue == maximumValue)
                            {
                                candidateCardsToThrow.push(c);
                            }
                            else if (c.rank.countValue &gt; maximumValue)
                            {
                                maximumValue = c.rank.countValue;

                                candidateCardsToThrow = [];

                                candidateCardsToThrow.push(c);
                            }
                        }
                    }
                }
            }
            else
            {
                if (candidateCardsToThrow.length == 0)
                {
                    let minimumValue = CardModel.rankFromName(&quot;Ace&quot;).countValue;

                    for (let c of myCards)
                    {
                        if (c.suit != TuteGame.pinta.suit)
                        {
                            if (c.rank.countValue == minimumValue)
                            {
                                candidateCardsToThrow.push(c);
                            }
                            else if (c.rank.countValue &lt; minimumValue)
                            {
                                minimumValue = c.rank.countValue;

                                candidateCardsToThrow = [];

                                candidateCardsToThrow.push(c);
                            }
                        }
                    }
                }
            }

            if (candidateCardsToThrow.length == 0)
                candidateCardsToThrow.push(myCards[0]);

        }

        return candidateCardsToThrow[parseInt(Math.random() * candidateCardsToThrow.length)];
    },

    calculatePlayerCardResponse: function(thrownCard)
    {
        const myCards = TuteGame.calculateAllowedCardsToAvoidRenuncio(thrownCard, TuteGame.player2Cards);

        let candidateCardsToThrow = [];

        if (thrownCard.rank.countValue == 0)
        {
            for (let c of myCards)
            {
                if (c.suit != TuteGame.pinta.suit &amp;&amp;
                    c.suit == thrownCard.suit &amp;&amp;
                    (c.rank.name == &quot;Ace&quot; || c.rank.name == &quot;V3&quot;))
                {
                    candidateCardsToThrow.push(c);
                }
            }

            if (candidateCardsToThrow.length == 0)
                return this.calculatePlayerCardBegin(myCards);
        }
        else
        {
            if (candidateCardsToThrow.length == 0)
            {
                for (let c of myCards)
                {
                    if (c.suit != TuteGame.pinta.suit &amp;&amp;
                        c.suit == thrownCard.suit &amp;&amp;
                        c.rank.countValue &gt; thrownCard.rank.countValue &amp;&amp;
                        (c.rank.name == &quot;Ace&quot; || c.rank.name == &quot;V3&quot;))
                    {
                        candidateCardsToThrow.push(c);
                    }
                }
            }

            if (candidateCardsToThrow.length == 0)
            {
                for (let c of myCards)
                {
                    if (c.suit == thrownCard.suit &amp;&amp;
                        c.rank.countValue &gt; thrownCard.rank.countValue)
                    {
                        candidateCardsToThrow.push(c);
                    }
                }
            }

            if (candidateCardsToThrow.length == 0)
            {
                if (thrownCard.suit != TuteGame.pinta.suit)
                {
                    for (let c of myCards)
                    {
                        if (c.suit == TuteGame.pinta.suit &amp;&amp;
                            c.rank.countValue == 0)
                        {
                            candidateCardsToThrow.push(c);
                        }
                    }
                }
            }
        }

        if (candidateCardsToThrow.length == 0)
            candidateCardsToThrow.push(myCards[0]);

        return candidateCardsToThrow[parseInt(Math.random() * candidateCardsToThrow.length)];
    }
}

const HumanPlayer =
{
    hoverCard: null,
	
    otherCurrentCards: [],
	
    onMouseOver: function(card, over)
    {
        if (over)
        {
            if (HumanPlayer.hoverCard == card)
                return;

            HumanPlayer.clearSelection();

            HumanPlayer.hoverCard = card;
        }
        else if (HumanPlayer.hoverCard != null)
        {
            HumanPlayer.clearSelection();

            HumanPlayer.hoverCard = null;
        }

        HumanPlayer._onMouseOver();
    },
    
	lastTouchedMovement: null,
	
	is_touch_device: function()
	{
	  var prefixes = &#039; -webkit- -moz- -o- -ms- &#039;.split(&#039; &#039;);
	  var mq = function(query) {
		return window.matchMedia(query).matches;
	  }

	  if ((&#039;ontouchstart&#039; in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch) {
		return true;
	  }

	  // include the &#039;heartz&#039; as a way to have a non matching MQ to help terminate the join
	  // https://git.io/vznFH
	  var query = [&#039;(&#039;, prefixes.join(&#039;touch-enabled),(&#039;), &#039;heartz&#039;, &#039;)&#039;].join(&#039;&#039;);
	  return mq(query);
	},

    _onMouseOver: function()
    {
		if (!HumanPlayer.is_touch_device())
		{
			let movement = HumanPlayer.getPlayerMovement();
	        
	        if (movement != null)
	            $(&quot;#player1Message&quot;).html(movement.toString());
		}
    },
	
	getPlayerMovement: function()
	{
		$(&quot;#player1Message&quot;).html(&quot;&quot;);

		let touchedMovement = HumanPlayer._getPlayerMovement();
			
		if (HumanPlayer.is_touch_device())
		{
			if (touchedMovement != null &amp;&amp; 
				HumanPlayer.lastTouchedMovement != null &amp;&amp;
				touchedMovement.toString() == HumanPlayer.lastTouchedMovement.toString())
			{
				return touchedMovement;
			}
			else
			{
				$(&quot;#player1Message&quot;).html(touchedMovement.toString());
				
				HumanPlayer.lastTouchedMovement = touchedMovement;
			}
		
			return null;
		}
		else
		{
			return touchedMovement;
		}
	},
    
    _getPlayerMovement: function()
    {
        if (HumanPlayer.hoverCard != null)
        {
            if (TuteGame.player1Turn)
            {
                if (TuteGame.canMakeDeclarations())
                {
                    if (HumanPlayer.hoverCard == TuteGame.pinta &amp;&amp; TuteGame.getPlayer1CardChangeableByPinta() != null)
                    {
                        HumanPlayer.hoverCard.setHighlightColor(Color.green);
                        
                        return new PintaMovement();
                    }
				}
				
				if (TuteGame.player1Cards.includes(HumanPlayer.hoverCard))
				{
					if (TuteGame.canMakeDeclarations())
					{
						if (HumanPlayer.hoverCard.rank.name == &quot;King&quot; || HumanPlayer.hoverCard.rank.name == &quot;Knight&quot;)
						{
                                if (TuteGame.canDeclareTute(HumanPlayer.hoverCard.rank, TuteGame.player1Cards))
							{
								for (let c of TuteGame.player1Cards)
								{
									if (c.rank == HumanPlayer.hoverCard.rank)
									{
										HumanPlayer.otherCurrentCards.push(c);
										
										c.setHighlightColor(Color.cyan);
									}
								}

								return new TuteMovement(HumanPlayer.hoverCard.rank);
							}
						}
						
						if (HumanPlayer.hoverCard.rank.name == &quot;King&quot; &amp;&amp;
							TuteGame.getDeclaration(TuteGame.pinta.suit) == null &amp;&amp;
							TuteGame.getDeclaration(HumanPlayer.hoverCard.suit) == null)
						{
							let knight = TuteGame.hasCard(CardModel.rankFromName(&quot;Knight&quot;), HumanPlayer.hoverCard.suit, TuteGame.player1Cards);
							
							if (knight != null)
							{
								HumanPlayer.otherCurrentCards.push(knight);
								
								HumanPlayer.hoverCard.setHighlightColor(Color.cyan);
								
								knight.setHighlightColor(Color.cyan);

								return new TwentyFortyMovement(TuteGame.pinta.suit, HumanPlayer.hoverCard.suit);
							}
						}
					}

					HumanPlayer.hoverCard.setHighlightColor(Color.yellow);
					
					return new ThrowMovement(HumanPlayer.hoverCard);
				}
            }
            else if (TuteGame.player1Cards.includes(HumanPlayer.hoverCard))
            {
				if (TuteGame.calculateIfRenuncio(TuteGameUI.player2playedCard, HumanPlayer.hoverCard, TuteGame.player1Cards))
					HumanPlayer.hoverCard.setHighlightColor(Color.pink);
				else
					HumanPlayer.hoverCard.setHighlightColor(Color.yellow);
			
                return new ThrowResponseMovement(HumanPlayer.hoverCard);
            }
        }
        
        return null;
    },

    clearSelection: function()
    {
        if (HumanPlayer.hoverCard != null)
            HumanPlayer.hoverCard.setHighlightColor(null);
		
		HumanPlayer.hoverCard = null;
        
        for (let c of HumanPlayer.otherCurrentCards)
            c.setHighlightColor(null);
        
        HumanPlayer.otherCurrentCards = [];
    }
}

const TuteGameUI =
{
    initialize: function()
    {
		TuteGameUI.updateGames();

        for (let card of GameUI.cards)
            AnimationController.add(new ReverseAnimator(card, false));

        AnimationController.add(TuteController.getDeckCardMove(GameUI.cards))

        for (let i = 0; i &lt; TuteGame.NUM_CARDS_PER_PLAYER; i ++)
            TuteGameUI.dealNewCards();

        AnimationController.add(new ReverseAnimator(TuteGame.pinta, true));

        AnimationController.add(TuteController.relocatePlayer1Cards(TuteGame.player1Cards));

        AnimationController.add(TuteController.relocatePlayer2Cards(TuteGame.player2Cards));

        AnimationController.add(TuteController.getPintaMovement(TuteGame.pinta));

        AnimationController.add(new WaitAnimator(50));

        AnimationController.addF(function()
        {
            TuteGameUI.startTurn();

            return true;
        })
    },

    dealNewCards: function()
    {
        if (TuteGame.deck.length == 0)
            return;

        if (TuteGame.player1Turn)
        {
            const c1 = TuteGame.dealCardToPlayer1();

            AnimationController.add(new MoveToFrontAnimator(c1));

            AnimationController.add(TuteController.getPlayer1CardThrow(c1));

            AnimationController.add(new ReverseAnimator(c1, true));
        }

        const c2 = TuteGame.dealCardToPlayer2();

        AnimationController.add(new MoveToFrontAnimator(c2));

        AnimationController.add(TuteController.getPlayer2PlayerCardThrow(c2));

        AnimationController.add(new ReverseAnimator(c2, false));

        if (!TuteGame.player1Turn)
        {
            const c1 = TuteGame.dealCardToPlayer1();

            AnimationController.add(new MoveToFrontAnimator(c1));

            AnimationController.add(TuteController.getPlayer1CardThrow(c1));

            AnimationController.add(new ReverseAnimator(c1, true));
        }
    },

    startTurn: function()
    {
		if (TuteGame.canMakeDeclarations())
		{
            const cardChangeableByPinta = TuteGame.getPlayer2CardChangeableByPinta();

            if (cardChangeableByPinta != null)
            {
                AnimationController.add(new ReverseAnimator(cardChangeableByPinta, true));

                AnimationController.add(new MoveToFrontAnimator(cardChangeableByPinta));

                AnimationController.add(TuteController.getPlayer2PintaCardThrow(cardChangeableByPinta));

                AnimationController.add(new MoveToBackAnimator(cardChangeableByPinta));

                AnimationController.add(new MessageAnimator(Tr.getChangePintaString(), 100));

                const previousPinta = TuteGame.changePintaPlayer2();

                AnimationController.add(TuteController.relocatePlayer2Cards(TuteGame.player2Cards));

                AnimationController.add(TuteController.getPintaMovement(TuteGame.pinta));

                AnimationController.add(new ReverseAnimator(previousPinta, false));

                AnimationController.addF(function()
                {
                    TuteGameUI.startTurn();

                    return true;
                });

                return;
            }
        }

        if (!TuteGame.player1Turn &amp;&amp; TuteGame.player1Cards.length &gt; 0)
        {
			if (TuteGame.canMakeDeclarations())
			{
				for (let rank of [ CardModel.rankFromName(&quot;King&quot;), CardModel.rankFromName(&quot;Knight&quot;) ])
				{
					if (TuteGame.canDeclareTute(rank, TuteGame.player2Cards))
					{
						for (let c of TuteGame.player2Cards)
						{
							if (c.rank == rank)
								AnimationController.add(new ReverseAnimator(c, true));
						}

						AnimationController.addF(function()
						{
							TuteGameUI.tute(rank);
							return true;
						});

						return;
					}
				}

				for (let declarationSuit of Suit)
				{
					if (TuteGame.getDeclaration(declarationSuit) != null ||
						TuteGame.getDeclaration(TuteGame.pinta.suit) != null)
						continue;

					const knight = TuteGame.hasCard(CardModel.rankFromName(&quot;Knight&quot;), declarationSuit, TuteGame.player2Cards);
					const king   = TuteGame.hasCard(CardModel.rankFromName(&quot;King&quot;),   declarationSuit, TuteGame.player2Cards);

					if (knight != null &amp;&amp; king != null)
					{
						TuteGame.declare(declarationSuit);

						AnimationController.add(new WaitAnimator(20));

						AnimationController.add(new ReverseAnimator(knight, true));
						AnimationController.add(new ReverseAnimator(king,   true));

						AnimationController.add(new MessageAnimator(
								Tr.getTwentyFortyDeclarationString(TuteGame.pinta.suit, declarationSuit), 100));

						AnimationController.addF(function()
						{
							TuteGameUI.fireWaitForUserClick(true);

							return true;
						});

						AnimationController.add(new ReverseAnimator(knight, false));
						AnimationController.add(new ReverseAnimator(king,   false));

						AnimationController.addF(function()
						{
							TuteGameUI.startTurn();

							return true;
						});

						return;
					}
				}
			}

            AnimationController.add(new WaitAnimator(20));

            TuteGameUI.player2playedCard = TuteAI.calculatePlayerCardBegin(TuteGame.player2Cards);

            AnimationController.add(new ReverseAnimator(TuteGameUI.player2playedCard, true));

            AnimationController.add(new MoveToFrontAnimator(TuteGameUI.player2playedCard));

            AnimationController.add(TuteController.getCenterCardThrow(TuteGameUI.player2playedCard));
        }

        AnimationController.addF(function()
        {
            TuteGameUI.fireWaitForUserClick(true);

            return true;
        });
    },

    fireWaitForUserClick: function(enable)
    {
		for (let card of GameUI.cards)
            card.highlightingEnabled = enable;

        if (enable)
        {
            GameUI.onCardClick = function(card)
            {
                let movement = HumanPlayer.getPlayerMovement();
            
				if (movement != null)
					TuteGameUI.onHumanMovement(movement);
				
                GameUI.repaint();
            };

            GameUI.onCardMouseEnter = function(card)
            {
                HumanPlayer.onMouseOver(card, true);
            };

            GameUI.onCardMouseLeave = function(card)
            {
                HumanPlayer.onMouseOver(card, false);
            };
        }
        else
        {
            GameUI.onCardClick      = null;
            GameUI.onCardMouseEnter = null;
            GameUI.onCardMouseLeave = null;
        }
    },

    onHumanMovement: function(movement)
    {
        if (movement != null)
        {
            this.fireWaitForUserClick(false);
            
            if (movement instanceof PintaMovement)
            {
                let cardChangeableByPinta = TuteGame.getPlayer1CardChangeableByPinta();
                
                if (cardChangeableByPinta == null)
                    throw new AssertionError();
                
                AnimationController.add(new MoveToFrontAnimator(cardChangeableByPinta));
                
                AnimationController.add(TuteController.getPlayer1PintaCardThrow(cardChangeableByPinta));
                
                AnimationController.add(new MoveToBackAnimator(cardChangeableByPinta));
    
                AnimationController.add(new MessageAnimator(Tr.getChangePintaString(), 100));
    
                TuteGame.changePintaPlayer1();
    
                AnimationController.add(TuteController.relocatePlayer1Cards(TuteGame.player1Cards));
    
                AnimationController.add(TuteController.getPintaMovement(TuteGame.pinta));

                AnimationController.addF(function()
                {
					TuteGameUI.fireWaitForUserClick(true);

					return true;
                });
            }
            else if (movement instanceof TuteMovement)
            {
                TuteGameUI.tute(movement.rank);
				
				return;
            }
            else if (movement instanceof TwentyFortyMovement)
            {
                TuteGame.declare(movement.suit);
                
                AnimationController.add(new MessageAnimator(
                        Tr.getTwentyFortyDeclarationString(
                                TuteGame.pinta.suit, movement.suit), 100));
    
                AnimationController.addF(function()
				{
					TuteGameUI.fireWaitForUserClick(true);

					return true;
                });
            }
            else if (movement instanceof ThrowMovement)
            {
                let currentCard = movement.currentCard;
                
                AnimationController.add(new MoveToFrontAnimator(currentCard));
                
                AnimationController.add(TuteController.getCenterCardThrow(currentCard));
    
                AnimationController.add(new WaitAnimator(20));
                
                let player2Card = TuteAI.calculatePlayerCardResponse(currentCard);
    
                AnimationController.add(new MoveToFrontAnimator(player2Card));
                
                AnimationController.add(TuteController.getCenterCardThrow(player2Card));
    
                AnimationController.add(new ReverseAnimator(player2Card, true));
                
                let player1Wins = TuteGame.playCards(currentCard, player2Card);
                
                TuteGameUI.playTurn(currentCard, player2Card, player1Wins);
            }
            else if (movement instanceof ThrowResponseMovement)
            {
                let currentCard = movement.currentCard;
                
                AnimationController.add(new MoveToFrontAnimator(currentCard));
    
                AnimationController.add(TuteController.getCenterCardThrow(currentCard));
    
                if (TuteGame.calculateIfRenuncio(TuteGameUI.player2playedCard, currentCard, TuteGame.player1Cards))
                {
                    TuteGameUI.renuncio(currentCard);
					
					return;
                }
                else
                {
                    let player1Wins = TuteGame.playCards(TuteGameUI.player2playedCard, currentCard);
                    
                    TuteGameUI.playTurn(currentCard, TuteGameUI.player2playedCard, player1Wins);
                    
                    TuteGameUI.player2playedCard = null;
                }
            }
        }
        
        HumanPlayer.clearSelection();
    },


    playTurn: function(card1, card2, player1Wins)
    {
        AnimationController.add(new WaitAnimator(20));
        
        if (player1Wins)
            AnimationController.add(TuteController.getPlayer1WinDeckMovement(card1, card2));
        else
            AnimationController.add(TuteController.getPlayer2WinDeckMovement(card1, card2));
        
        AnimationController.addF(function()
        {
			TuteGameUI.newTurn(player1Wins);
			
			return true;
        });
    },

    newTurn: function(player1WonLastTrick)
    {
        if (TuteGame.arePlayerCardsEmpty())
        {
            TuteGameUI.completeGame(player1WonLastTrick);
        }
        else
        {
            TuteGameUI.dealNewCards();
            
            AnimationController.add(TuteController.relocatePlayer1Cards(TuteGame.player1Cards));
            
            AnimationController.add(TuteController.relocatePlayer2Cards(TuteGame.player2Cards));
            
            AnimationController.addF(function()
            {
				GameUI.repaint();
		
				TuteGameUI.startTurn();
				
				return true;
            });
        }
    },

    completeGame(player1WonLastTrick)
    {
		HumanPlayer.clearSelection();
		
        let player1Wins = TuteGame.player1Baza.reverse();
        let player2Wins = TuteGame.player2Baza.reverse();
        
        AnimationController.add(TuteController.getCenterWinCardThrow(player1Wins));
        
        this.player1Points = 0;
        this.player2Points = 0;
        
        for (let card of player1Wins)
        {
            AnimationController.add(new MoveToFrontAnimator(card));
            AnimationController.add(TuteController.getCenterCardThrow(card));
            AnimationController.add(new ReverseAnimator(card, true));
            
            if (card.rank.countValue &gt; 0)
            {
                AnimationController.addF(function()
                {
					TuteGameUI.player1Points += card.rank.countValue;
					TuteGameUI.updateGames();
					return true;
                });

                AnimationController.add(new MessageAnimator(Tr.getPlusPointsString(card.rank.countValue), 30));
            }
        }

        if (player1WonLastTrick)
        {
            AnimationController.add(new WaitAnimator(15));

            AnimationController.addF(function()
            {
				TuteGameUI.player1Points += 10;
				TuteGameUI.updateGames();
				return true;
            });

            AnimationController.add(new MessageAnimator(Tr.getPlus10DeMonteString(), 30));
        }

        for (let suit of Suit)
        {
            let declaration = TuteGame.getDeclaration(suit);
            
            if (declaration == &quot;1&quot;)
            {
                AnimationController.add(new WaitAnimator(15));

                let points = suit == TuteGame.pinta.suit ? 40 : 20;
                
                AnimationController.addF(function()
                {
					TuteGameUI.player1Points += points;
					TuteGameUI.updateGames();
					return true;
                });

                AnimationController.add(new MessageAnimator(Tr.getPlusTwentyFortyPointsString(points, suit), 30));
            }
        }
        
        AnimationController.add(new WaitAnimator(50));
        
        AnimationController.add(TuteController.getCenterWinCardThrow(player2Wins));

        for (let card of player2Wins)
        {
            AnimationController.add(new MoveToFrontAnimator(card));
            AnimationController.add(TuteController.getCenterCardThrow(card));
            AnimationController.add(new ReverseAnimator(card, true));
            
            if (card.rank.countValue &gt; 0)
            {
                AnimationController.addF(function()
                {
					TuteGameUI.player2Points += card.rank.countValue;
					TuteGameUI.updateGames();
					return true;
                });

                AnimationController.add(new MessageAnimator(Tr.getPlusPointsString(card.rank.countValue), 30));
            }
        }

        if (!player1WonLastTrick)
        {
            AnimationController.add(new WaitAnimator(15));

            AnimationController.addF(function()
            {
				TuteGameUI.player2Points += 10;
				TuteGameUI.updateGames();
				return true;
            });

            AnimationController.add(new MessageAnimator(Tr.getPlus10DeMonteString(), 30));
        }
        
        for (let suit of Suit)
        {
            let declaration = TuteGame.getDeclaration(suit);
            
            if (declaration == &quot;2&quot;)
            {
                AnimationController.add(new WaitAnimator(15));

                let points = suit == TuteGame.pinta.suit ? 40 : 20;
                
                AnimationController.addF(function()
                {
					TuteGameUI.player2Points += points;
					TuteGameUI.updateGames();
					return true;
                });

                AnimationController.add(new MessageAnimator(Tr.getPlusTwentyFortyPointsString(points, suit), 30));
            }
        }
        
        AnimationController.addF(function()
        {
			TuteGame.countPointsAndRestart(player1WonLastTrick);
			
			return true;
        });
        
        AnimationController.add(new WaitAnimator(100));
        
        AnimationController.add(TuteController.getCenterCardMove(GameUI.cards));
        
        AnimationController.addF(function()
        {
			TuteGameUI.player1Points = TuteGameUI.player2Points = -1;

			TuteGameUI.initialize();
			
			return true;
        });
    },

    renuncio: function(currentCard)
    {
        TuteGame.declareRenuncio(this.player2playedCard, currentCard);
        
        this.abortGame(Tr.getDeclareRenuncioString());
    },
    
    tute: function(rank)
    {
        TuteGame.declareTute();
    
        this.abortGame(Tr.getTuteDeclarationString(rank));
    },
    
    abortGame: function(message)
    {
        AnimationController.add(new MessageAnimator(message, 100));
        
        AnimationController.add(TuteController.getCenterCardMove(GameUI.cards));

		HumanPlayer.clearSelection();
		
        AnimationController.addF(function()
        {
			TuteGame.countPointsAndRestart(TuteGame.player1Turn);
			TuteGameUI.initialize();
			return true;
        });
    },
	
	updateGames: () =&gt;
	{
		if (TuteGameUI.player1Points &gt; 0)
			$(&quot;#player1Points&quot;).html(Tr.getPlayerPointsString(TuteGameUI.player1Points));
		else
			$(&quot;#player1Points&quot;).html(&quot;&quot;);
		
		if (TuteGameUI.player2Points &gt; 0)
			$(&quot;#player2Points&quot;).html(Tr.getPlayerPointsString(TuteGameUI.player2Points));
		else
			$(&quot;#player2Points&quot;).html(&quot;&quot;);

		$(&quot;#player2Message&quot;).html(Tr.getPlayerGamesString(TuteGame.player1Games, TuteGame.player2Games));
	}
}

$(() =&gt;
{
	$(&quot;title&quot;).html(Tr.getWindowTitle());
	
    GameUI.initialize();

    $(window).resize(GameUI.onResize);

    GameUI.repaint();

    AnimationController.initialize();

    TuteGame.initialize();

    TuteGameUI.initialize();
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ cyclomatic }} <br>
    Length : {{ halstead.length }} <br>
    Difficulty : {{ halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
